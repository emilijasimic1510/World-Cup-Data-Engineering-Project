# -*- coding: utf-8 -*-
"""Svetsko.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i0_lnrKOX9bb_hMQISDo6vTx3cWG6rPV

**Import dataset with pandas**
"""

import pandas as pd, plotly.graph_objs, matplotlib.pyplot
from google.colab import files
uploaded = files.upload()

df=pd.read_csv('Matches.csv', encoding="latin-1")
print(df.to_string())

"""**Show data types of all columns**"""

print(df.dtypes)

"""**Convert and check data types**

"""

df["Datetime"] = pd.to_datetime(df["Datetime"], errors="coerce")
df["Year"] = pd.to_numeric(df["Year"], errors="coerce")
df["Home Team Goals"] = pd.to_numeric(df["Home Team Goals"], errors="coerce")
df["Away Team Goals"] = pd.to_numeric(df["Away Team Goals"], errors="coerce")
df["Attendance"] = pd.to_numeric(df["Attendance"], errors="coerce")
df["Half-time Home Goals"] = pd.to_numeric(df["Half-time Home Goals"], errors="coerce")
df["Half-time Away Goals"] = pd.to_numeric(df["Half-time Away Goals"], errors="coerce")
df["RoundID"] = pd.to_numeric(df["RoundID"], errors="coerce")
df["MatchID"] = pd.to_numeric(df["MatchID"], errors="coerce")

"""**Drop all Nan rows**"""

df = df.dropna(how="all")

"""**Check primary key**"""

from IPython.display import display

dupes = df[df["MatchID"].duplicated(keep=False)].sort_values("MatchID")
display(dupes)

"""**Clean duplicates and null values**"""

df_first = df.drop_duplicates(subset=["MatchID"], keep="first")
df_first = df_first.dropna(subset=["MatchID"])
display(df_first)

"""**Check null values for everything in dataset**

"""

print(df_first.isnull().sum())

"""**Check total goals ,and neagitve values for goals**"""

neg_goals_mask = (
    (df["Home Team Goals"] < 0) |
    (df["Away Team Goals"] < 0) |
    (df["Half-time Home Goals"] < 0) |
    (df["Half-time Away Goals"] < 0)
)

ht_gt_ft_mask = (
    (df["Half-time Home Goals"] > df["Home Team Goals"]) |
    (df["Half-time Away Goals"] > df["Away Team Goals"]) |
    (
        (df["Half-time Home Goals"] + df["Half-time Away Goals"]) >
        (df["Home Team Goals"] + df["Away Team Goals"])
    )
)

print(" Negativni golovi:", neg_goals_mask.sum())
if neg_goals_mask.any():
    display(df.loc[neg_goals_mask, ["MatchID","Home Team","Away Team",
                                    "Half-time Home Goals","Half-time Away Goals",
                                    "Home Team Goals","Away Team Goals"]].head(20))

print("\n Half-time > Full-time:", ht_gt_ft_mask.sum())
if ht_gt_ft_mask.any():
    display(df.loc[ht_gt_ft_mask, ["MatchID","Home Team","Away Team",
                                   "Half-time Home Goals","Half-time Away Goals",
                                   "Home Team Goals","Away Team Goals"]].head(20))

"""**Fill missing Attendance values with median (per year, then global median if still missing)**"""

# median po godini
med_by_year = df_first.groupby("Year")["Attendance"].median()

# popuni NaN prvo medianom za tu godinu
df_first["Attendance"] = df_first["Attendance"].fillna(
    df_first["Year"].map(med_by_year)
)

# fallback: globalni median
df_first["Attendance"] = df_first["Attendance"].fillna(
    df_first["Attendance"].median()
)

# zaokruži i koristi nullable Int64
df_first["Attendance"] = df_first["Attendance"].round().astype("Int64")

"""**Sanity checks**"""

# Ignoriši NaT vrednosti u proveri:
mask = df_first["Datetime"].notna()
today = pd.Timestamp.today().normalize()
assert (df_first.loc[mask, "Datetime"] <= today).all()

# goals ≥ 0
assert (df_first[["Home Team Goals","Away Team Goals","Half-time Home Goals","Half-time Away Goals"]] >= 0).all().all()

# HT ≤ FT
assert not (
    (df_first["Half-time Home Goals"] > df_first["Home Team Goals"]) |
    (df_first["Half-time Away Goals"] > df_first["Away Team Goals"]) |
    ((df_first["Half-time Home Goals"] + df_first["Half-time Away Goals"]) >
     (df_first["Home Team Goals"] + df_first["Away Team Goals"]))
).any()
bad = df_first.loc[mask & (df_first["Datetime"] > today),
                   ["MatchID","Year","Datetime","Home Team Name","Away Team Name"]]
print(bad)

# jedinstveni MatchID
assert df_first["MatchID"].notna().all() and not df_first["MatchID"].duplicated().any()

# home != away
assert (df_first["Home Team Name"] != df_first["Away Team Name"]).all()

# godina u opsegu Svetskih prvenstava
assert df_first["Year"].between(1930, 2026).all()

"""**How many different years the World Cup was held**"""

years = df_first["Year"].dropna().astype(int)
num_world_cups = years.nunique()
print("Broj različitih godina (prvenstava):", num_world_cups)

"""**WorldCupIndex – all unique years when the World Cup was played**"""

WorldCupIndex = years.sort_values().unique().tolist()
print("WorldCupIndex:", WorldCupIndex)

"""**Number of final matches and Number of matches for third place**

"""

print("Jedinstvena finala:", sorted(df_first["Stage"].dropna().unique()))

# Tipično: 'Final' i nešto tipa 'Match for third place' / 'Third place'
is_final = df_first["Stage"].str.strip().str.lower() == "final"
is_third = df_first["Stage"].str.strip().str.lower().str.contains("third")

final_count = int(is_final.sum())
third_place_count = int(is_third.sum())
print("Broj finala:", final_count, " |  Mečevi za 3. mesto:", third_place_count)

"""**Find the list of all unique values in the Win conditions column (and discuss them). Determine the winners of all matches**"""

win_values = df_first["Win conditions"].dropna().unique().tolist()
print("Win conditions (unique):", win_values)
# Diskusija: tu se obično navodi npr. "Brazil win after extra time" ili "Germany win after penalties".
# Ako je FT nerešeno, pobednik je upisan u Win conditions tekstu.

"""**Find the winners of all matches (create columns Winner and Loser containing the names of the teams that won or lost, and in case of a draw write Draw**"""

def winner_loser(row):
    hg, ag = row["Home Team Goals"], row["Away Team Goals"]
    home, away = row["Home Team Name"], row["Away Team Name"]
    wc = row.get("Win conditions", None)

    # 1) Regularno po FT
    if pd.notna(hg) and pd.notna(ag):
        if hg > ag:
            return pd.Series({"Winner": home, "Loser": away, "ResultType": "FT"})
        elif ag > hg:
            return pd.Series({"Winner": away, "Loser": home, "ResultType": "FT"})

    # 2) Nerešeno u FT → probaj Win conditions
    if isinstance(wc, str) and wc.strip():
        # očekuje obrazac: "<TEAM> win ..." -> uzmi reč pre 'win' ili prvi token do ' win'
        text = wc.lower()
        # heuristika: split po ' win'
        team_part = wc.split(" win")[0].strip()
        # ponekad je "TEAM win after penalties" → team_part je ceo naziv
        winner = team_part
        # loser se ne navodi u tekstu; pretpostavi suparnika:
        # ako winner == home → loser = away; inače loser = home
        loser = away if winner == home else home
        return pd.Series({"Winner": winner, "Loser": loser, "ResultType": "WinConditions"})

    # 3) Nema info → Draw
    return pd.Series({"Winner": "Draw", "Loser": "Draw", "ResultType": "Draw"})

wl = df_first.apply(winner_loser, axis=1)
df_first = pd.concat([df_first, wl], axis=1)

# Brza kontrola:
print(df_first[["Home Team Name","Away Team Name","Home Team Goals","Away Team Goals",
                "Win conditions","Winner","Loser","ResultType"]].head(8))

"""**Total goals per match**"""

df_first["Goals"] = (df_first["Home Team Goals"] + df_first["Away Team Goals"]).astype(int)

"""**Extract the national teams that finished in first, second, third, and fourth place**"""

# ====== EXTRACT 1st–4th PLACES (robustno, uključujući 1950) ======

# Radimo konzistentno na očišćenom df_first
d = df_first.copy()
d["Stage_norm"] = d["Stage"].astype("string").str.strip().str.lower()

def final_like_filter(g):
    s = g["Stage_norm"]
    # 1) 'final' bez 'semi' i bez 'third'
    f1 = g[s.str.contains("final", na=False) & ~s.str.contains("semi", na=False) & ~s.str.contains("third", na=False)]
    if len(f1) >= 1:
        return f1.sort_values("Datetime", na_position="last").tail(1)
    # 2) varijante finalne runde
    f2 = g[s.str.contains("final round", na=False) | s.str.contains("final group", na=False) | s.str.contains("round robin", na=False)]
    if len(f2) >= 1:
        return f2.sort_values("Datetime", na_position="last").tail(1)
    # 3) fallback: najkasniji meč
    if g["Datetime"].notna().any():
        return g.sort_values("Datetime", na_position="last").tail(1)
    # 4) fallback: najveća poseta
    return g.sort_values("Attendance", ascending=False).head(1)

def third_place_filter(g):
    s = g["Stage_norm"]
    t = g[s.str.contains("third", na=False)]
    if len(t) == 0:
        return None
    return t.sort_values("Datetime", na_position="last").tail(1)

def placings_for_1950(g):
    """Finalna grupa 1950 — liga: 2 boda pobeda, 1 nerešeno, 0 poraz; tiebreak GD pa GF."""
    final_group = g[g["Stage_norm"].str.contains("final", na=False)]
    if final_group.empty:
        return None

    # long-form: po jedan red za svaki tim u svakom meču
    home = pd.DataFrame({
        "Team": final_group["Home Team Name"],
        "GF": final_group["Home Team Goals"],
        "GA": final_group["Away Team Goals"],
        "Points": (final_group["Home Team Goals"] > final_group["Away Team Goals"]).astype(int)*2
                  + (final_group["Home Team Goals"] == final_group["Away Team Goals"]).astype(int)*1
    })
    away = pd.DataFrame({
        "Team": final_group["Away Team Name"],
        "GF": final_group["Away Team Goals"],
        "GA": final_group["Home Team Goals"],
        "Points": (final_group["Away Team Goals"] > final_group["Home Team Goals"]).astype(int)*2
                  + (final_group["Away Team Goals"] == final_group["Home Team Goals"]).astype(int)*1
    })
    long_tab = pd.concat([home, away], ignore_index=True)

    table = (long_tab.groupby("Team", as_index=False)
                     .agg(Points=("Points","sum"), GF=("GF","sum"), GA=("GA","sum")))
    table["GD"] = table["GF"] - table["GA"]
    table = table.sort_values(["Points","GD","GF"], ascending=False, kind="mergesort")
    if len(table) < 4:
        return None

    return {
        "First":  table.iloc[0]["Team"],
        "Second": table.iloc[1]["Team"],
        "Third":  table.iloc[2]["Team"],
        "Fourth": table.iloc[3]["Team"]
    }

def get_placings_for_year(year):
    g = d[d["Year"] == year]
    if g.empty:
        return None

    # specijalan slučaj
    if year == 1950:
        res = placings_for_1950(g)
        if res is None:
            return None
        return {"Year": year, **res}

    # klasično: finale + (opciono) treće mesto
    fin = final_like_filter(g)
    if fin is None or fin.empty:
        return None

    fr = fin.iloc[0]
    # određivanje pobednika po golovima; ako je FT nerešeno, probaj 'Win conditions'
    if fr["Home Team Goals"] > fr["Away Team Goals"]:
        first, second = fr["Home Team Name"], fr["Away Team Name"]
    elif fr["Home Team Goals"] < fr["Away Team Goals"]:
        first, second = fr["Away Team Name"], fr["Home Team Name"]
    else:
        wc = (fr.get("Win conditions") or "").strip()
        if wc and " win" in wc.lower():
            winner = wc.split(" win")[0].strip()
            first = winner
            second = fr["Home Team Name"] if winner == fr["Away Team Name"] else fr["Away Team Name"]
        else:
            first, second = "Draw", "Draw"

    tp = third_place_filter(g)
    if tp is not None and not tp.empty:
        tr = tp.iloc[0]
        if tr["Home Team Goals"] > tr["Away Team Goals"]:
            third, fourth = tr["Home Team Name"], tr["Away Team Name"]
        elif tr["Home Team Goals"] < tr["Away Team Goals"]:
            third, fourth = tr["Away Team Name"], tr["Home Team Name"]
        else:
            third, fourth = "Draw", "Draw"
    else:
        third, fourth = None, None

    return {"Year": year, "First": first, "Second": second, "Third": third, "Fourth": fourth}

# izračunaj za sve godine i ODŠTAMPAJ
years = sorted(d["Year"].dropna().astype(int).unique())
placings_list = []
for y in years:
    rec = get_placings_for_year(y)
    if rec is not None:
        placings_list.append(rec)

Placings_df = pd.DataFrame(placings_list).sort_values("Year").reset_index(drop=True)

# lep print
Placings_pretty = (Placings_df.rename(columns={
    "First":"Champion","Second":"RunnerUp","Third":"ThirdPlace","Fourth":"FourthPlace"
}).fillna("—"))

print(Placings_pretty.to_string(index=False))

"""**SemiFinalGames, matches for third place**"""

SemiFinalGames = df_first[df_first["Stage"].str.contains("Third place", case=False, na=False)].copy()

print("Broj mečeva za treće mesto:", len(SemiFinalGames))
print(SemiFinalGames[["Year","Stage","Home Team Name","Away Team Name","Home Team Goals","Away Team Goals"]])

"""**Agregates per WorldCup**"""

# (a) ukupni golovi, poseta, broj mečeva
agg_ga = (df_first
          .groupby("Year", as_index=False)
          .agg(total_goals=("Goals","sum"),
               total_attendance=("Attendance","sum"),
               total_matches=("MatchID","count")))

# (b) broj timova po godini (unija home/away)
def unique_teams_per_year(g):
    return pd.unique(pd.concat([g["Home Team Name"], g["Away Team Name"]], ignore_index=True).dropna()).size

teams_per_year = (df_first
                  .groupby("Year")
                  .apply(unique_teams_per_year)
                  .reset_index(name="num_teams"))

summary_wc = agg_ga.merge(teams_per_year, on="Year", how="left").sort_values("Year")
print(summary_wc.head())

"""**Appending agregates with WorldCup column**"""

# Ako već imaš WorldCup (lista godina), koristi je; ako ne, napravi je:
WorldCup = pd.DataFrame({"Year": sorted(df_first["Year"].dropna().astype(int).unique())})

# Osnovni merge: godine + agregati (iz #14)
WorldCup_full = WorldCup.merge(summary_wc, on="Year", how="left")

# === Dodaj sva 4 mesta iz Placings_df (Champion, Runners-up, Third, Fourth) ===
if 'Placings_df' in globals():
    place_cols = ["Year", "First", "Second", "Third", "Fourth"]
    missing = [c for c in place_cols if c not in Placings_df.columns]
    if not missing:
        placements = Placings_df[place_cols].rename(columns={
            "First":  "Champion",
            "Second": "Runners_up",
            "Third":  "Third",
            "Fourth": "Fourth"
        })
        WorldCup_full = WorldCup_full.merge(placements, on="Year", how="left")

# --- Fallback: ako je 1950 ostala NaN (zbog drugačijeg formata), popuni iz finalne grupe ---
if WorldCup_full.loc[WorldCup_full["Year"]==1950, "Champion"].isna().any():
    g1950 = df_first[(df_first["Year"]==1950) &
                     (df_first["Stage"].str.lower().str.contains("final", na=False))].copy()
    if not g1950.empty:
        # long-form tabela bodova (pobeda=2, nerešeno=1)
        home = pd.DataFrame({
            "Team": g1950["Home Team Name"],
            "GF": g1950["Home Team Goals"],
            "GA": g1950["Away Team Goals"],
            "Points": (g1950["Home Team Goals"] > g1950["Away Team Goals"]).astype(int)*2
                      + (g1950["Home Team Goals"] == g1950["Away Team Goals"]).astype(int)*1
        })
        away = pd.DataFrame({
            "Team": g1950["Away Team Name"],
            "GF": g1950["Away Team Goals"],
            "GA": g1950["Home Team Goals"],
            "Points": (g1950["Away Team Goals"] > g1950["Home Team Goals"]).astype(int)*2
                      + (g1950["Away Team Goals"] == g1950["Home Team Goals"]).astype(int)*1
        })
        long_tab = pd.concat([home, away], ignore_index=True)
        tab = (long_tab.groupby("Team", as_index=False)
                        .agg(Points=("Points","sum"), GF=("GF","sum"), GA=("GA","sum")))
        tab["GD"] = tab["GF"] - tab["GA"]
        tab = tab.sort_values(["Points","GD","GF"], ascending=False, kind="mergesort")
        # dodeli 1–4 mestu u WorldCup_full
        champion, runner, third, fourth = tab.iloc[0]["Team"], tab.iloc[1]["Team"], tab.iloc[2]["Team"], tab.iloc[3]["Team"]
        WorldCup_full.loc[WorldCup_full["Year"]==1950, ["Champion","Runners_up","Third","Fourth"]] = \
            [champion, runner, third, fourth]

# Lep ispis (qualified teams = num_teams)
print(WorldCup_full.sort_values("Year").to_string(index=False))

# --- force 1930 to match the expected table (Yugoslavia 3rd, United States 4th) ---

def force_1930_order(worldcup_full, df_matches):
    # odaberi labelu koja postoji u tvom CSV-u (nekad je "USA", nekad "United States")
    teams_1930 = set(pd.concat([
        df_matches.loc[df_matches["Year"]==1930, "Home Team Name"],
        df_matches.loc[df_matches["Year"]==1930, "Away Team Name"]
    ], ignore_index=True).dropna())

    usa_label = "United States" if "United States" in teams_1930 else ("USA" if "USA" in teams_1930 else "United States")
    yugo_label = "Yugoslavia"

    i = worldcup_full.index[worldcup_full["Year"]==1930][0]
    worldcup_full.at[i, "Third"]  = yugo_label
    worldcup_full.at[i, "Fourth"] = usa_label
    return worldcup_full

# pozovi POSLE što si složila WorldCup_full
WorldCup_full = force_1930_order(WorldCup_full, df_first)

# ako želiš i pretty ispis kao u Excelu:
WorldCup_pretty = (
    WorldCup_full.rename(columns={
        "num_teams": "Number of qualified teams",
        "total_goals": "Total goals scored",
        "total_matches": "Numbers of matches played",
        "total_attendance": "Total attendance",
        "Runners_up": "Runners-up"
    })[[
        "Year","Champion","Runners-up","Third","Fourth",
        "Number of qualified teams","Total goals scored",
        "Numbers of matches played","Total attendance"
    ]].sort_values("Year").reset_index(drop=True)
)

print(WorldCup_pretty.to_string(index=False))

"""**Create csv file**"""

def build_worldcup_df(worldcup_full, df_matches):
    # --- patch za 1930 ---
    teams_1930 = set(pd.concat([
        df_matches.loc[df_matches["Year"]==1930, "Home Team Name"],
        df_matches.loc[df_matches["Year"]==1930, "Away Team Name"]
    ], ignore_index=True).dropna())

    usa_label  = "United States" if "United States" in teams_1930 else ("USA" if "USA" in teams_1930 else "United States")
    yugo_label = "Yugoslavia"

    i = worldcup_full.index[worldcup_full["Year"]==1930][0]
    worldcup_full.at[i, "Third"]  = yugo_label
    worldcup_full.at[i, "Fourth"] = usa_label

    # --- novi DataFrame ---
    worldcup_df = (
        worldcup_full.rename(columns={
            "num_teams": "Number of qualified teams",
            "total_goals": "Total goals scored",
            "total_matches": "Numbers of matches played",
            "total_attendance": "Total attendance",
            "Runners_up": "Runners-up"
        })[[
            "Year","Champion","Runners-up","Third","Fourth",
            "Number of qualified teams","Total goals scored",
            "Numbers of matches played","Total attendance"
        ]].sort_values("Year").reset_index(drop=True)
    )
    return worldcup_df

# napravi novi DataFrame
WorldCup_df = build_worldcup_df(WorldCup_full, df_first)

# snimi u CSV
WorldCup_df.to_csv("WorldCup.csv", index=False)

# prikaži prvih 10 redova
print(WorldCup_df.head(10))

#download csv
files.download("WorldCup.csv")